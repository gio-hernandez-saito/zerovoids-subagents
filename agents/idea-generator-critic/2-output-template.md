# Output Template Specification

> Defines the Markdown document structure for generated project ideas

---

## ðŸ“‹ Complete Template

```markdown
---
{FRONTMATTER from 1-frontmatter-spec.md}
---

# {Title}

> {One-line hook - compelling, specific, intriguing}

## ðŸŽ¯ The Problem

### Current Situation
{Describe the problem context in 2-3 sentences. What exists now? What's wrong with it?}

### Pain Points
- **{Specific pain 1}**: {Why it hurts}
- **{Specific pain 2}**: {Impact/frequency}
- **{Specific pain 3}**: {Consequences}

### Who Experiences This?
{Target audience - be specific about who suffers from this problem}

---

## ðŸ’¡ The Solution

### Core Concept
{The main idea in 3-4 sentences. What is this project? How does it solve the problem?}

### How It Works
1. **{Step 1}**: {What happens}
2. **{Step 2}**: {Process/flow}
3. **{Step 3}**: {Result/output}

### Key Features
- **{Feature 1}**: {What it does, why it matters}
- **{Feature 2}**: {Unique aspect}
- **{Feature 3}**: {User benefit}

---

## ðŸ—ï¸ Technical Architecture

### System Overview

{ASCII diagram or simple description of architecture}
```

### Tech Stack Rationale
- **{Technology 1}**: {Why chosen, what it provides}
- **{Technology 2}**: {Strengths for this use case}
- **{Technology 3}**: {Specific capability needed}

### Key Technical Challenges
1. **{Challenge 1}**: {Why difficult, potential approach}
2. **{Challenge 2}**: {Technical hurdle, considerations}

---

## ðŸŽ¨ What Makes This Interesting?

### Unique Angle
{What's different about this approach? Why hasn't this been done before?}

### Innovation Points
- {Novel technique or combination}
- {Fresh perspective on problem}
- {Unexpected application of technology}

### Learning Opportunities
- {New skill 1}
- {Technical challenge 2}
- {Domain knowledge 3}

---

## ðŸ“Š Market & Validation

### Similar Projects
- **{Project 1}** ([link]): {How it differs from this}
- **{Project 2}** ([link]): {Gap this fills}

### Why This Gap Exists
{Explain why current solutions are insufficient or why this hasn't been built}

### Success Indicators
- [ ] {Measurable outcome 1}
- [ ] {User feedback criterion}
- [ ] {Technical milestone}

---

## ðŸš€ Implementation Roadmap

### Phase 1: MVP (Week 1)
**Goal**: {Core functionality only}
- {Essential feature 1}
- {Essential feature 2}
- {Basic UI/interaction}

### Phase 2: Enhancement (Week 2)
**Goal**: {Improved experience}
- {Additional feature}
- {Polish core flow}
- {Error handling}

### Phase 3: Refinement (Week 3)
**Goal**: {Production ready}
- {Performance optimization}
- {Documentation}
- {Testing coverage}

### Technical Milestones
| Week | Deliverable   | Success Criteria    |
|------|---------------|---------------------|
| 1    | {MVP feature} | {Works end-to-end}  |
| 2    | {Enhancement} | {Quality threshold} |
| 3    | {Polish}      | {Ready to share}    |

---

## ðŸŒ± What You'll Learn

### New Skills & Concepts
- **{Skill 1}**: {What you'll understand deeply}
- **{Skill 2}**: {New technique or paradigm}
- **{Skill 3}**: {Transferable knowledge}

### Growth Opportunities
- {Conceptual understanding you'll gain}
- {Problem-solving pattern you'll internalize}
- {Domain knowledge expansion}

### Stretch Points
{Where does this push you outside your comfort zone?}

---

## ðŸŒ Open Source Potential

### Community Value
{Who benefits? What problem does this solve for others?}

### Reusability
{Can others fork/extend? What makes it modular?}

### Documentation Plan
- README with quickstart
- API/usage documentation
- Example use cases
- Contributing guidelines

---

## ðŸ’­ Extensions & Future Work

### Natural Extensions
- {Feature that builds on core}
- {Related problem to solve}
- {Integration opportunity}

### Research Questions
- {Open question 1}
- {Experimental direction}
- {Advanced feature to explore}

### Community Contributions
{What could others add? Where is extension encouraged?}

---

## ðŸ”— Related Context

**Inspiration**: {Brief note on what sparked this idea}

**Related Projects**: {Links to connected work}

**References**: {Relevant articles, papers, tools}

---

**Generated by**: idea-generator-critic agent  
**Evaluation Score**: {X.X}/10 (after {N} iterations)  
**Status**: âœ… Ready for consideration
```

---

## ðŸ“ Section Guidelines

### Title & Hook

#### Title
```yaml
format: "Clear, Specific Project Name"
length: 3-8 words
style: Title Case

good:
  - "Monorepo Dependency Visualizer"
  - "Baseball Pitch Sequence Analyzer"
  - "MCP Workflow Orchestrator"

bad:
  - "My Cool App" # vague
  - "The Ultimate Developer Tool for Modern Web Applications" # too long
  - "tool-name" # not title case
```

#### One-line Hook
```yaml
purpose: Make reader want to learn more
length: 10-20 words
style: Conversational, intriguing

formula: "{What} that {unique value} for {who}"

good:
  - "Explore your codebase like a Metroidvania game, uncovering connections as you navigate."
  - "Turn baseball pitch data into interactive stories that reveal strategy patterns."
  - "Automate your entire MCP workflow with a single configuration file."

bad:
  - "A tool for developers." # too generic
  - "This revolutionary groundbreaking innovative solution..." # overselling
  - "Uses React and TypeScript to build stuff." # too technical for hook
```

---

### The Problem

#### Current Situation
```yaml
purpose: Set context, establish shared understanding
length: 2-4 sentences
tone: Objective, factual

structure:
  - What exists now
  - What's the general issue
  - Why it matters

example:
  "Navigating large codebases feels like wandering through endless corridors.
  Developers spend 60% of their time understanding code relationships rather
  than writing new code. Current tools show static dependency graphs but miss
  the exploratory nature of learning a codebase."
```

#### Pain Points
```yaml
format: 3-5 bullet points
structure: "**{Specific pain}**: {Why it hurts}"

guidelines:
  - Be specific, not generic
  - Include frequency or impact
  - Real developer experience
  - Concrete examples

good:
  - "**Mental model overload**: Jumping between 20+ files to understand one feature"
  - "**Lost context**: Forgetting why you opened a file by the time you find it"
  - "**No progression sense**: Can't track what you've explored vs what's new"

bad:
  - "It's hard to use" # too vague
  - "The UI is ugly" # subjective
  - "There are some issues" # not specific
```

#### Who Experiences This?
```yaml
purpose: Define target audience
specificity: More specific = better

good:
  - "Frontend developers working in React monorepos with 100+ components"
  - "Baseball analysts who need to present findings to non-technical coaches"
  - "Solo developers managing multiple MCP servers across projects"

bad:
  - "Developers" # too broad
  - "Anyone who codes" # not helpful
  - "People interested in data" # vague
```

---

### The Solution

#### Core Concept
```yaml
purpose: Explain the idea clearly
length: 3-5 sentences
tone: Confident, clear

structure:
  - What is it (noun)
  - How does it work (verb)
  - What's the outcome (benefit)
  - What's unique (differentiator)

example:
  "Metroidvania Code Explorer turns your codebase into a 3D navigable world.
  Each file is a room, imports are doors, and exploring reveals the
  architecture naturally. As you navigate, the map fills in, giving you a
  spatial memory of your code's structure. Unlike static graphs, this makes
  learning a codebase feel like an adventure game."
```

#### How It Works
```yaml
format: 3-5 numbered steps
structure: "**{Action}**: {Explanation}"

focus:
  - User journey, not technical implementation
  - Concrete steps, not abstract concepts
  - Clear flow from input to output

good:
  - "**Load project**: Point to your repository root"
  - "**Spawn in entry point**: Start in index.js as your 'spawn room'"
  - "**Navigate via imports**: Click import statements to 'enter' other files"

bad:
  - "**Parse AST**: System analyzes syntax trees" # too technical
  - "**Magic happens**: It does stuff" # too vague
  - "**Win**: You're done!" # not helpful
```

#### Key Features
```yaml
format: 3-5 features
structure: "**{Feature name}**: {What it does and why}"

guidelines:
  - Lead with user benefit
  - Include unique aspects
  - Mix must-have and nice-to-have
  - Concrete not abstract

good:
  - "**Memory map**: Auto-generates a visual map of explored files, with unexplored areas grayed out"
  - "**Backtracking**: Navigate backwards through your exploration history"
  - "**Power-ups**: Unlock shortcuts like 'jump to definition' after exploring enough"

bad:
  - "**Works well**: It's really good" # meaningless
  - "**Uses TypeScript**: Built with modern tech" # implementation detail
  - "**Fast**: Optimized for speed" # claims without specifics
```

---

### Technical Architecture

#### System Overview
```yaml
format: ASCII diagram or paragraph
purpose: High-level architecture understanding

ascii_example: |
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Parser    â”‚ (AST analysis)
  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
  â”‚ Graph Model â”‚ (file relationships)
  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
  â”‚ 3D Renderer â”‚ (Three.js)
  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
  â”‚  Web UI     â”‚ (React)
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

paragraph_example:
  "Three-layer architecture: Parser layer analyzes code and builds
  dependency graph. Model layer manages navigation state and exploration
  history. Renderer layer translates graph to 3D world using Three.js,
  wrapped in React components for UI controls."

guidelines:
  - Clear flow of data
  - Major components only
  - Relationships between parts
```

#### Tech Stack Rationale
```yaml
purpose: Justify technology choices
format: Technology + Why

good:
  - "**Three.js**: Handles 3D rendering and camera controls without
    writing WebGL. Mature ecosystem for spatial navigation."
  - "**TypeScript Parser**: Leverage existing tools (ts-morph) for AST
    analysis rather than building parser from scratch."

bad:
  - "**React**: It's popular" # weak reasoning
  - "**TypeScript**: Type safety" # obvious
```

#### Key Technical Challenges
```yaml
format: 2-4 challenges
structure: "**{Challenge}**: {Why hard, potential solution}"

focus:
  - Real technical hurdles
  - Not solved problems
  - Interesting to solve

good:
  - "**3D layout algorithm**: How to spatially arrange files meaningfully?
    Could use force-directed graph or hierarchical tree layout."
  - "**Performance with large codebases**: 1000+ files as 3D objects.
    Need LOD system or chunked loading."

bad:
  - "**Installing dependencies**: Might take a while" # not a challenge
  - "**Writing code**: Will need to code it" # obvious
```

---

### What Makes This Interesting?

#### Unique Angle
```yaml
purpose: Differentiate from existing solutions
tone: Confident but honest

structure:
  - What's novel
  - Why hasn't this been done
  - What makes it special

avoid:
  - Claiming "first ever" (rarely true)
  - Attacking competitors
  - Overselling uniqueness
```

#### Innovation Points
```yaml
format: 2-4 bullet points
focus: Technical novelty OR application novelty

types:
  - Novel combination: "D3 + Three.js for hybrid 2D/3D viz"
  - Fresh metaphor: "Codebase as explorable game world"
  - Unique data: "Pitch sequences as narrative arcs"
  - New technique: "OKLCH color space for accessible palettes"

good:
  - "Spatial memory for code navigation (game-inspired)"
  - "Treats dependencies as traversable space, not static graph"

bad:
  - "Uses modern JavaScript" # not innovative
  - "Has good UX" # claim without substance
```

#### Learning Opportunities
```yaml
format: 3-5 bullet points
purpose: What you'll learn building this

good:
  - "Three.js scene management and camera controls"
  - "AST parsing and code analysis techniques"
  - "Force-directed graph algorithms"

bad:
  - "JavaScript" # too basic
  - "How to code" # not specific
```

---

### Market & Validation

#### Similar Projects
```yaml
format: 2-4 projects with links
structure: "**{Project}** (link): {How yours differs}"

purpose:
  - Show awareness of landscape
  - Highlight your unique value
  - Demonstrate gap

good:
  - "**Code Compass** (github.com/...): 2D graph view.
    This adds 3D exploration with game-like progression."
  - "**Sourcetrail** (discontinued): Desktop app.
    This is web-based and emphasizes discovery over search."

note: Being honest about alternatives shows maturity
```

#### Why This Gap Exists
```yaml
purpose: Explain opportunity
length: 2-3 sentences

reasons:
  - Technical challenge
  - Niche need
  - Changing context
  - Novel combination

example:
  "Existing tools treat code visualization as static analysis, not
  exploration. Game-inspired navigation hasn't been applied to dev
  tools. WebGL performance only recently became viable for this."
```

---

### Implementation Roadmap

#### Phase Structure
```yaml
phases: 3 typically (MVP, Enhancement, Refinement)
timeframe: 1-3 weeks total

MVP_focus:
  - Core value prop only
  - Minimal viable experience
  - Proof of concept

Enhancement_focus:
  - Improved UX
  - Additional features
  - Better feedback

Refinement_focus:
  - Polish
  - Performance
  - Documentation
  - Testing
```

#### Milestone Table
```yaml
purpose: Concrete deliverables with dates
format: Markdown table

columns:
  - Week/Phase
  - Deliverable (what gets built)
  - Success criteria (how to know it's done)
```

**Good example:**
| Week | Deliverable | Success Criteria |
| 1 | File parser + basic 3D render | See 10 files as 3D rooms |
| 2 | Navigation + map system | Can explore and see progress |
| 3 | Polish + docs | Shareable demo ready |

**Bad example:**
| Week | Deliverable | Success Criteria |
| 1 | Some stuff | It works |
| 2 | More stuff | Looks good |

---

### What You'll Learn

#### New Skills & Concepts
```yaml
format: 3-5 learning outcomes
structure: "**{Skill}**: {What you'll understand}"

focus:
  - Deep conceptual understanding
  - New techniques or paradigms
  - Transferable knowledge
  - Domain expertise

good:
  - "**3D graphics fundamentals**: Scene graphs, camera math, render pipelines"
  - "**Graph algorithms**: Force-directed layouts, traversal patterns"
  - "**State management patterns**: When to use different approaches"

bad:
  - "**JavaScript**: Will use JavaScript" # too basic
  - "**React**: Learn React" # vague
```

#### Growth Opportunities
```yaml
purpose: Identify stretch areas
format: 2-4 specific growth points

good:
  - "Understanding why force-directed beats tree layout for certain graph types"
  - "Internalizing WebGL performance patterns through hands-on optimization"
  - "Building intuition for when to chunk data vs load eagerly"

bad:
  - "Will learn stuff" # not specific
  - "Good experience" # not informative
```

---

### Open Source Potential

#### Community Value
```yaml
questions:
  - Who else has this problem?
  - What makes it reusable?
  - Why would others fork/star?

good:
  "Any dev working in large codebases benefits. Config-driven so works
  with any language. Plugin system for custom visualizations."

bad:
  "Maybe some people would like it" # vague
```

#### Documentation Plan
```yaml
essentials:
  - README with quickstart
  - API/usage docs
  - Examples
  - Contributing guide

good:
  - "Interactive demo site with sample repo"
  - "Plugin development guide with examples"
  - "Video walkthrough of key features"

realistic:
  - Start with good README
  - Add docs as needed
  - Don't overpromise
```

---

## âœ… Quality Checklist

Before finalizing document, verify:

### Content
- [ ] Problem clearly defined and relatable
- [ ] Solution explained without jargon
- [ ] Technical approach makes sense
- [ ] Unique value is evident
- [ ] Implementation seems feasible
- [ ] All sections have substance (not filler)

### Tone
- [ ] Confident without overselling
- [ ] Specific without being tedious
- [ ] Honest about challenges
- [ ] Acknowledges similar work
- [ ] Explains "why" not just "what"

### Completeness
- [ ] All template sections filled
- [ ] Examples are concrete
- [ ] Technical details sufficient
- [ ] Timeline is realistic
- [ ] Success criteria are measurable

### Writing
- [ ] No generic phrases ("powerful tool", "revolutionary")
- [ ] Active voice preferred
- [ ] Consistent tense
- [ ] Proper Markdown formatting
- [ ] Links are valid (if external)

---

## ðŸŽ¨ Style Guidelines

### Voice & Tone
```yaml
be:
  - Clear and direct
  - Enthusiastic but realistic
  - Specific over generic
  - Honest about trade-offs

avoid:
  - Marketing speak
  - Passive voice
  - Weasel words ("probably", "might", "could be")
  - Excessive qualifiers
```

### Technical Writing
```yaml
principle: Be specific over generic

examples:
  - before: "Very fast loading"
    after: "Loads 1000 files in under 2 seconds"
  
  - before: "Advanced graphics capabilities"
    after: "Three.js for 3D rendering"
  
  - before: "For developers working on large projects"
    after: "Targets React monorepos with 100+ components"
```

### Structure
```yaml
paragraphs:
  - "2-4 sentences typically"
  - "One idea per paragraph"
  - "Clear transitions"

lists:
  - "Use when appropriate (not always)"
  - "Consistent structure within list"
  - "Parallel construction"

emphasis:
  - "Bold for feature names, key terms"
  - "Italic for emphasis (sparingly)"
  - "Code backticks for technical terms"
  - "No ALL CAPS (except acronyms)"
```

---

## ðŸ“Š Example Outputs

See `1-frontmatter-spec.md` for complete example frontmatters.

### Minimal Acceptable Quality
```markdown
# Component Dependency Visualizer

> See how your React components connect at a glance

## ðŸŽ¯ The Problem

Large React codebases become tangled webs of component dependencies...
(continues with substance, not fluff)
```

### High Quality Target
```markdown
# Metroidvania Code Explorer

> Navigate your codebase like exploring an interconnected game world

## ðŸŽ¯ The Problem

### Current Situation
Developers spend most of their time reading code, not writing it. Yet our
tools treat codebases as static file trees. Understanding how pieces connect
requires mental gymnastics across dozens of files.

### Pain Points
- **Memory overload**: Opening 20 tabs just to trace one feature
- **Lost context**: Forgetting why you opened a file
- **No sense of progress**: Can't see what you've explored

### Who Experiences This?
Developers onboarding to large codebases, or returning to complex projects
after months away. Especially common in monorepos where navigation tools
treat all packages equally.

(continues with depth and specifics throughout)
```

---

## ðŸ”— Related Documents

- `0-context.md`: Informs content style and technical choices
- `1-frontmatter-spec.md`: Required YAML header
- `3-evaluation-criteria.md`: What makes a good document

---

**Last Updated**: 2026-01-17
