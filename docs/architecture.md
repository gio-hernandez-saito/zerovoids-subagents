# 아키텍처 및 설계 철학

## 핵심 철학

**"흩어진 조각들을 우주로 만들다"**

이 저장소는 하나의 근본 원칙을 구현합니다: 경험의 모든 조각은 적절히 구조화되고 문서화되면 재사용 가능한 자산이 됩니다. 지식이 프로젝트와 맥락 사이에 흩어지도록 두지 않고, 패턴을 체계적으로 배포할 수 있는 Agent로 결정화합니다.

---

## 설계 원칙

### 1. 명확성 > 영리함

각 Agent는 즉시 이해 가능해야 합니다:
- 명확하고 서술적인 이름
- 명시적인 트리거 조건
- 잘 문서화된 책임
- 암묵적 동작 없음

**이유:** 설명이 필요한 Agent는 자산이 아니라 부채입니다.

### 2. 구체성 > 범용성

Agent는 집중된, 명확히 정의된 범위를 가져야 합니다:
- 모호한 Agent 1개보다 구체적인 Agent 10개가 낫습니다
- 각 Agent는 자신의 도메인에서 탁월합니다
- 명확한 경계가 중복을 방지합니다

**이유:** 전문화가 전문성을 만듭니다. 범용 Agent는 유지보수 악몽이 됩니다.

### 3. 조합 가능성 > 모놀리스

Agent들은 함께 작동해야 합니다:
- 작고 집중된 단위
- 명확한 인터페이스 (description을 통해)
- 명시적인 위임 패턴
- Profile 기반 조합

**이유:** 복잡한 워크플로우는 간단하고 조합 가능한 부품에서 나옵니다.

### 4. 진화 > 완벽

구조는 현실에 적응해야 합니다:
- 간단하게 시작하고 필요에 따라 복잡성 추가
- 실제 사용 패턴을 기반으로 리팩토링
- 조기 최적화 금지

**이유:** 최고의 아키텍처는 계획이 아닌 사용에서 나옵니다.

---

## 저장소 구조

### `/agents` - 핵심 자산

```
agents/
├── _template.md     # Agent 구조의 원본
├── core/           # 프레임워크 무관, 보편적으로 유용
├── specialized/    # 도메인 특화 전문성
└── meta/          # 자체 관리 및 메타 작업
```

**근거:**
- `core/`: 특별한 컨텍스트 없이 어디서나 작동
- `specialized/`: 특정 도메인 지식 필요 (React, 데이터베이스 등)
- `meta/`: 저장소 자체를 관리 (자체 호스팅 원칙)

### `/bin` - 개발자 경험

확장자 없는 Unix 스타일 CLI 도구:
- `setup`: 프로젝트 통합
- `validate`: 품질 게이트
- `add-agent`: 스캐폴딩
- `generate-catalog`: 카탈로그 생성 (예정)

**근거:** 명령어는 스크립트가 아니라 네이티브처럼 느껴져야 합니다.

### `/docs` - 사고 과정

"무엇"뿐만 아니라 "왜":
- `architecture.md`: 이 파일 - 설계 결정
- `commit-guidelines.md`: 커밋 규칙 빠른 참조

**근거:** 미래의 유지보수자(미래의 나 포함)는 코드뿐만 아니라 맥락이 필요합니다.

### `/profiles` - 조합 패턴

사전 구성된 Agent 조합:
- `default.json`: 합리적인 기본값

**근거:** 일반적인 패턴은 한 명령으로 접근 가능해야 합니다.

---

## Agent 설계 패턴

### 패턴 1: 트리거 기반

```yaml
description: Use PROACTIVELY when [구체적 조건]
```

Description이 인터페이스입니다. Claude Code는 이를 사용해 위임 시점을 결정합니다.

### 패턴 2: 명확한 범위

```markdown
## Responsibilities
Primary: [하나의 명확한 목표]
Secondary: [지원 목표]

## Limitations
- [하지 말아야 할 것]
```

경계가 범위 확장과 Agent 간 충돌을 방지합니다.

### 패턴 3: 예시 기반

```markdown
## Examples
### Example 1: [구체적 시나리오]
Input: [특정 상황]
Action: [Agent가 하는 일]
Output: [예상 결과]
```

예시는 테스트이자 문서화를 동시에 수행합니다.

---

## 자동화 철학

### 3단계 계층

**계층 1: 품질 게이트** (CI/CD)
- 머지 전 반드시 통과
- 구조, 네이밍, 완전성 검증
- 협상 불가

**계층 2: 생산성** (개발 도구)
- 마찰 감소
- 빠른 반복 가능
- 스캐폴딩, 생성

**계층 3: 지능** (분석)
- 사용 패턴 학습
- 개선 제안
- 사용되지 않는 코드 식별

### 자체 관리 원칙

저장소는 자신의 Agent를 사용해 자신을 관리해야 합니다:
- `meta/repo-manager.md` - 구조 검증
- Claude Code가 이 저장소에서 작동

**이유:** 우리 도구가 우리에게 충분히 좋지 않다면, 다른 사람에게도 충분히 좋지 않습니다.

---

## 안티패턴

### ❌ 피해야 할 것

1. **만능 Agent**: 모든 것을 하는 하나의 Agent
2. **암묵적 동작**: 문서화되지 않은 부작용
3. **복붙 Agent**: 약간의 차이만 있는 거의 동일한 Agent들
4. **오래된 문서**: 현실과 맞지 않는 문서
5. **조기 추상화**: 필요가 증명되기 전의 복잡한 구조

### ✅ 대신 해야 할 것

1. **집중된 전문가**: 각 Agent는 하나의 명확한 작업
2. **명시적 인터페이스**: Description이 모든 것을 설명
3. **조합을 통한 DRY**: 중복하지 말고 조합
4. **자동 생성 문서**: 도구가 카탈로그 유지
5. **유기적 성장**: 패턴이 나타날 때 구조 추가

---

## 진화 전략

### Phase 1: 기초 (현재)
- 기본 구조
- 핵심 Agent
- 필수 도구
- 문서화

### Phase 2: 개선 (1-2개월 후)
- 사용 패턴 식별
- 데이터 기반 재구조화
- 특화 Agent 추가
- 자동화 개선

### Phase 3: 성숙 (3-6개월 후)
- 안정적 구조
- 포괄적 커버리지
- 고급 분석
- 커뮤니티 기여

---

## 성공 측정

이 저장소는 다음 조건에서 성공합니다:

1. **첫 Agent까지 소요 시간** < 5분
   - 빠른 설정, 즉각적 가치

2. **Agent 생성** < 10분
   - 아이디어에서 작동하는 Agent까지

3. **문서 부채 제로**
   - 자동 생성 카탈로그가 항상 최신

4. **자급자족**
   - 저장소가 자신의 Agent를 통해 자신을 관리

5. **포트폴리오 가치**
   - 체계적 사고와 아키텍처 기술 시연

---

## 설계 결정

### 왜 Markdown + YAML Frontmatter?

- 사람이 읽기 쉬움
- Git 친화적 (diff, merge)
- 모든 곳에서 에디터 지원
- 빌드 단계 불필요

### 왜 Bash 스크립트?

- Unix 시스템에서 보편적
- 의존성 없음
- 명확하고 감사 가능
- 수정하기 쉬움

### 왜 Profile에 JSON?

- 기계 판독 가능
- 확장 가능
- 표준 형식
- 검증하기 쉬움

### 왜 core/specialized/meta 분리?

- 명확한 멘탈 모델
- 관심사 혼합 방지
- 탐색하기 쉬움
- 확장성 좋음

---

## 미래 고려사항

### 잠재적 추가 사항

- `/templates` - 프로젝트 스캐폴딩 템플릿
- `/integrations` - IDE 플러그인, Git hooks
- `/benchmarks` - Agent 효과성 지표
- `/community` - 기여된 Agent

### 열린 질문들

- Agent 버전 관리?
- Agent 의존성 그래프?
- 성능 지표?
- A/B 테스팅 프레임워크?

이것들은 실제 필요가 나타날 때 다룰 것입니다.

---

**기억하세요**: 아키텍처는 작업을 위해 존재하지, 그 반대가 아닙니다. 확신이 없다면 간단한 것을 배포하고 현실에 기반해 반복하세요.

---

**Last Updated**: 2026-01-14
